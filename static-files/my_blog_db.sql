/*
SQLyog Ultimate v13.1.1 (64 bit)
MySQL - 8.0.19 : Database - my_blog_db
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`my_blog_db` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `my_blog_db`;

/*Table structure for table `generator_test` */

DROP TABLE IF EXISTS `generator_test`;

CREATE TABLE `generator_test` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `test` varchar(100) NOT NULL COMMENT '测试字段',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `generator_test` */

/*Table structure for table `jdbc_test` */

DROP TABLE IF EXISTS `jdbc_test`;

CREATE TABLE `jdbc_test` (
  `type` varchar(100) DEFAULT NULL COMMENT '类型',
  `name` varchar(100) DEFAULT NULL COMMENT '名称'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `jdbc_test` */

insert  into `jdbc_test`(`type`,`name`) values 
('com.zaxxer.hikari.HikariDataSource','hikari数据源'),
('org.apache.commons.dbcp2.BasicDataSource','dbcp2数据源'),
('test','测试类'),
('类别2','测试类2');

/*Table structure for table `tb_admin_user` */

DROP TABLE IF EXISTS `tb_admin_user`;

CREATE TABLE `tb_admin_user` (
  `admin_user_id` int NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `login_user_name` varchar(50) NOT NULL COMMENT '管理员登陆名称',
  `login_password` varchar(50) NOT NULL COMMENT '管理员登陆密码',
  `nick_name` varchar(50) NOT NULL COMMENT '管理员显示昵称',
  `locked` tinyint DEFAULT '0' COMMENT '是否锁定 0未锁定 1已锁定无法登陆',
  PRIMARY KEY (`admin_user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `tb_admin_user` */

insert  into `tb_admin_user`(`admin_user_id`,`login_user_name`,`login_password`,`nick_name`,`locked`) values 
(1,'admin','e10adc3949ba59abbe56e057f20f883e','李志豪',0);

/*Table structure for table `tb_blog` */

DROP TABLE IF EXISTS `tb_blog`;

CREATE TABLE `tb_blog` (
  `blog_id` bigint NOT NULL AUTO_INCREMENT COMMENT '博客表主键id',
  `blog_title` varchar(200) NOT NULL COMMENT '博客标题',
  `blog_sub_url` varchar(200) NOT NULL COMMENT '博客自定义路径url',
  `blog_cover_image` varchar(200) NOT NULL COMMENT '博客封面图',
  `blog_content` mediumtext NOT NULL COMMENT '博客内容',
  `blog_category_id` int NOT NULL COMMENT '博客分类id',
  `blog_category_name` varchar(50) NOT NULL COMMENT '博客分类(冗余字段)',
  `blog_tags` varchar(200) NOT NULL COMMENT '博客标签',
  `blog_status` tinyint NOT NULL DEFAULT '0' COMMENT '0-草稿 1-发布',
  `blog_views` bigint NOT NULL DEFAULT '0' COMMENT '阅读量',
  `enable_comment` tinyint NOT NULL DEFAULT '0' COMMENT '0-允许评论 1-不允许评论',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`blog_id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

/*Data for the table `tb_blog` */

insert  into `tb_blog`(`blog_id`,`blog_title`,`blog_sub_url`,`blog_cover_image`,`blog_content`,`blog_category_id`,`blog_category_name`,`blog_tags`,`blog_status`,`blog_views`,`enable_comment`,`is_deleted`,`create_time`,`update_time`) values 
(1,'我是志豪','about','http://localhost:8083/admin/dist/img/rand/8.jpg','## About me\n\n我是志豪，一名自学者，一直渴望进步，同时也努力活着，为了人生不留遗憾，也希望能够一直做着自己喜欢的事情，得闲时分享心得、分享一些浅薄的经验，等以后老得不能再老了，就说故事已经讲完了,不去奢求圆满。\n\n相信浏览这段话的你也知道，学习是一件极其枯燥而无聊的过程，甚至有时候显得很无助，我也想告诉你，成长就是这样一件残酷的事情，任何成功都不是一蹴而就，需要坚持、需要付出、需要你的毅力，短期可能看不到收获，因为破茧成蝶所耗费的时间不是一天。\n\n## Contact\n\n- 我的邮箱：448635854@qq.com\n- 我的网站：http://codelizh.cn\n\n\n\n\n## Quote\n\n- Steve Jobs\n\n> Stay hungry,Stay foolish\n\n- Kahlil Gibran\n\n>The FIRST TIME WHEN I saw her being meek that she might attain height.<br>\nThe SECOND TIME WHEN I saw her limping BEFORE the crippled.<br>\nThe third TIME WHEN she was given TO choose BETWEEN the hard AND the easy, AND she chose the easy.<br>\nThe fourth TIME WHEN she COMMITTED a wrong, AND comforted herself that others also COMMIT wrong.<br>\nThe fifth TIME WHEN she forbore FOR weakness, AND attributed her patience TO strength.<br>\nThe sixth TIME WHEN she despised the ugliness of a face, AND knew NOT that it was ONE of her own masks.<br>\nAND the seventh TIME WHEN she sang a song of praise, AND deemed it a virtue.',20,'About','世界上有一个很可爱的人,现在这个人就在看这句话',1,316,0,0,'2017-03-12 00:31:15','2018-11-12 00:31:15'),
(2,'文章总目录','','/admin/dist/img/rand/13.jpg','<h2 id=\"springboot2\">23 个实验带你轻松玩转 Spring Boot</h2>\n\n- [**开篇词：《23 个实验带你轻松玩转 Spring Boot》导读**](https://www.shiyanlou.com/courses/1274)\n- [第02课：Spring Boot 项目开发环境搭建](https://www.shiyanlou.com/courses/1274)\n- [第03课：快速构建 Spring Boot 应用](https://www.shiyanlou.com/courses/1274)\n- [第04课：Spring Boot 基础功能开发](https://www.shiyanlou.com/courses/1274)\n- [第05课：Spring Boot 项目开发之 web 项目开发讲解](https://www.shiyanlou.com/courses/1274)\n- [第06课：Spring Boot 整合 JSP 开发 web 项目](https://www.shiyanlou.com/courses/1274)\n- [第07课：模板引擎介绍及 Spring Boot 整合 Thymeleaf](https://www.shiyanlou.com/courses/1274)\n- [第08课：Thymeleaf 语法详解](https://www.shiyanlou.com/courses/1274)\n- [第09课：FreeMarker 模板引擎整合使用教程](https://www.shiyanlou.com/courses/1274)\n- [第10课：Spring Boot 处理文件上传及路径回显](https://www.shiyanlou.com/courses/1274)\n- [第11课：Spring Boot 自动配置数据源及操作数据库](https://www.shiyanlou.com/courses/1274)\n- [第12课：Spring Boot 整合 Druid 数据源](https://www.shiyanlou.com/courses/1274)\n- [第13课：Spring Boot 整合 MyBatis 操作数据库](https://www.shiyanlou.com/courses/1274)\n- [第14课：Spring Boot 中的事务处理](https://www.shiyanlou.com/courses/1274)\n- [第15课：Spring Boot 整合 Redis 操作缓存模块](https://www.shiyanlou.com/courses/1274)\n- [第16课：Spring Boot 项目开发之实现定时任务](https://www.shiyanlou.com/courses/1274)\n- [第17课：Spring Boot 自定义错误页面](https://www.shiyanlou.com/courses/1274)\n- [第18课：Spring Boot 集成 Swagger 生成接口文档](https://www.shiyanlou.com/courses/1274)\n- [第19课：Spring Boot 项目打包部署介绍](https://www.shiyanlou.com/courses/1274)\n- [第20课：Spring Boot Admin 介绍及整合使用](https://www.shiyanlou.com/courses/1274)\n- [第21课：Spring Boot 资讯管理信息系统开发实战(一)](https://www.shiyanlou.com/courses/1274)\n- [第22课：Spring Boot 资讯管理信息系统开发实战(二)](https://www.shiyanlou.com/courses/1274)\n- [第23课：Spring Boot 资讯管理信息系统开发实战(三)](https://www.shiyanlou.com/courses/1274)\n- [第24课：Spring Boot 资讯管理信息系统开发实战(四)](https://www.shiyanlou.com/courses/1274)\n\n<h2 id=\"springboot1\">Spring Boot 入门及前后端分离项目实践</h2>\n\n* [开篇词：SpringBoot入门及前后端分离项目实践导读](https://www.shiyanlou.com/courses/1244)\n* [第02课：快速认识 Spring Boot 技术栈](https://www.shiyanlou.com/courses/1244)\n* [第03课：开发环境搭建](https://www.shiyanlou.com/courses/1244)\n* [第04课：快速构建 Spring Boot 应用](https://www.shiyanlou.com/courses/1244)\n* [第05课：Spring Boot 之基础 web 功能开发](https://www.shiyanlou.com/courses/1244)\n* [第06课：Spring Boot 之数据库连接操作](https://www.shiyanlou.com/courses/1244)\n* [第07课：Spring Boot 整合 MyBatis 操作数据库](https://www.shiyanlou.com/courses/1244)\n* [第08课：Spring Boot 处理文件上传及路径回显](https://www.shiyanlou.com/courses/1244)\n* [第09课：Spring Boot 项目实践之前后端分离详解](https://www.shiyanlou.com/courses/1244)\n* [第10课：Spring Boot 项目实践之 API 设计](https://www.shiyanlou.com/courses/1244)\n* [第11课：Spring Boot 项目实践之登录模块实现](https://www.shiyanlou.com/courses/1244)\n* [第12课：Spring Boot 项目实践之分页功能实现](https://www.shiyanlou.com/courses/1244)\n* [第13课：Spring Boot 项目实践之jqgrid分页整合](https://www.shiyanlou.com/courses/1244)\n* [第14课：Spring Boot 项目实践之编辑功能实现](https://www.shiyanlou.com/courses/1244)\n* [第15课：Spring Boot 项目实践之用户管理模块实现](https://www.shiyanlou.com/courses/1244)\n* [第16课：Spring Boot 项目实践之图片管理模块](https://www.shiyanlou.com/courses/1244)\n* [第17课：Spring Boot 项目实践之富文本编辑器介绍及整合](https://www.shiyanlou.com/courses/1244)\n* [第18课：Spring Boot 项目实践之信息管理模块实现](https://www.shiyanlou.com/courses/1244)\n\n<h2 id=\"ssm4\">从零开始搭建一个精美且实用的管理后台</h2>\n\n- [SSM 搭建精美实用的管理系统](http://gitbook.cn/m/mazi/comp/column?columnId=5b4dae389bcda53d07056bc9&sceneId=22778a708b0f11e8974b497483da0812)\n- [导读：自己动手实现 JavaWeb 后台管理系统](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4db47e9bcda53d07056f5f)\n- [第01课：Spring MVC+ Spring + Mybatis “三大框架”介绍](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4db5b89bcda53d070590de)\n- [第02课：前期准备工作及基础环境搭建](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4eb8e701d18a561f341b72)\n- [第03课：三大框架的整合](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4ee11c01d18a561f342c0f)\n- [第04课：Tomcat 8 安装部署及功能改造](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1335dbb1436093a6ca17)\n- [第05课：产品设计之搭建精美实用的后台管理系统](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b35dbb1436093a6cc7a)\n- [第06课：前端选型 AdminLTE3](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b70dbb1436093a6cc87)\n- [第07课：登录模块的系统设计和实现](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b80dbb1436093a6cc8e)\n- [第08课：使用 JqGrid 插件实现分页功能](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b92dbb1436093a6cc93)\n- [第09课：弹框组件整合——完善添加和修改功能](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1bbddbb1436093a6cc9b)\n- [第10课：图片管理模块](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1bd0dbb1436093a6cca1)\n- [第11课：多图上传与大文件分片上传、断点续传](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1bdedbb1436093a6cca2)\n- [第12课：文件导入导出功能](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1beddbb1436093a6cca8)\n- [第13课：富文本信息管理模块](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c00dbb1436093a6ccae)\n- [第14课：SweetAlert 插件整合及搜索功能实现](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c11dbb1436093a6ccb1)\n- [第15课：项目发布——Linux 命令及发布流程](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c21dbb1436093a6ccb6)\n- [第16课：项目优化篇之日志输出](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c30dbb1436093a6ccbb)\n- [第17课：项目优化之单元测试](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c3fdbb1436093a6ccc1)\n- [第18课：项目优化之数据库连接池](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c50dbb1436093a6ccca)\n- [第19课：项目优化之 Druid 整合](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c65dbb1436093a6cccd)\n- [第20课：项目优化之缓存整合](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c7cdbb1436093a6ccd6)\n- [第21课：网站架构演进及 Nginx 介绍](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c8bdbb1436093a6ccda)\n- [第22课：Nginx + Tomcat 集群搭建](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c9ddbb1436093a6cce2)\n- [第23课：Nginx 动静分离](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1cb7dbb1436093a6cceb)\n\n<h2 id=\"ssm3\">SSM整合进阶篇</h2>\n\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（一）设计一套好的RESTful API](http://www.cnblogs.com/han-1034683568/p/7196345.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（二）RESTful API实战笔记(接口设计及Java后端实现)](http://www.cnblogs.com/han-1034683568/p/7300547.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（三）使用ajax方法实现form表单的提交](http://www.cnblogs.com/han-1034683568/p/7199168.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（四）RESTful实战(前端代码修改)](http://www.cnblogs.com/han-1034683568/p/7552007.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（五）记录一下从懵懂到理解RESTful的过程](http://www.cnblogs.com/han-1034683568/p/7569870.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（六）一定要RESTful吗？](http://www.cnblogs.com/han-1034683568/p/7663641.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（七）一次线上Mysql数据库崩溃事故的记录](http://www.cnblogs.com/han-1034683568/p/7787659.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（八）线上Mysql数据库崩溃事故的原因和处理](http://www.cnblogs.com/han-1034683568/p/7822237.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（九）Linux下安装redis及redis的常用命令和操作](http://www.cnblogs.com/han-1034683568/p/7862188.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十）easyUI整合KindEditor详细教程](http://www.cnblogs.com/han-1034683568/p/7930542.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十一）redis密码设置、安全设置](http://www.cnblogs.com/han-1034683568/p/7978577.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十二）Spring集成Redis缓存](http://www.cnblogs.com/han-1034683568/p/7994231.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十三）MyBatis+MySQL返回插入的主键id](http://www.cnblogs.com/han-1034683568/p/8305122.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十四）Redis正确的使用姿势](http://www.cnblogs.com/han-1034683568/p/8406497.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十五）阶段总结](http://www.cnblogs.com/han-1034683568/p/9069008.html)\n\n<h2 id=\"idea\">Intellij IDEA相关笔记</h2>\n\n- [如何查看IntelliJ IDEA的版本信息](http://www.cnblogs.com/han-1034683568/p/9135192.html)\n- [Plugin \'Lombok Plugin\' is incompatible with this installation](http://www.cnblogs.com/han-1034683568/p/9135074.html)\n- [IDEA安装Lombok插件失败的解决方案](http://www.cnblogs.com/han-1034683568/p/9134980.html)\n- [Intellij IDEA debug模式下项目启动慢/无法启动的事件解决过程记录](http://www.cnblogs.com/han-1034683568/p/8603588.html)\n- [Intellij IDEA查看所有断点](http://www.cnblogs.com/han-1034683568/p/8603110.html)\n- [IntelliJ IDEA 报错：Error:java: 未结束的字符串文字](http://www.cnblogs.com/han-1034683568/p/6439723.html)\n- [IntelliJ IDEA 常用快捷键mac版](http://www.cnblogs.com/han-1034683568/p/6492342.html)\n\n<h2 id=\"diary\">日常手记</h2>\n\n- [开启mac上印象笔记的代码块](http://www.cnblogs.com/han-1034683568/p/9021263.html)\n- [程序员，你怎么这么忙？](http://www.cnblogs.com/han-1034683568/p/8968959.html)\n- [新购阿里云服务器ECS创建之后无法ssh连接的问题处理](http://www.cnblogs.com/han-1034683568/p/8856560.html)\n- [CentOS 7.2:Failed to start IPv4 firewall with iptables](http://www.cnblogs.com/han-1034683568/p/8854613.html)\n- [JDK8 stream toMap() java.lang.IllegalStateException: Duplicate key异常解决(key重复)](http://www.cnblogs.com/han-1034683568/p/8624447.html)\n- [我在博客园的这一年小记](http://www.cnblogs.com/han-1034683568/p/8443428.html)\n- [记录一下我的2017年阅读书单](http://www.cnblogs.com/han-1034683568/p/8432261.html)\n- [2017总结](http://www.cnblogs.com/han-1034683568/p/8337394.html)\n- [微信公众号问题：{\"errcode\":40125,\"errmsg\":\"invalid appsecret, view more at http:\\/\\/t.cn\\/LOEdzVq, hints: [ req_id: kL8J90219sg58 ]\"}](http://www.cnblogs.com/han-1034683568/p/8286777.html)\n- [git删除本地分支](http://www.cnblogs.com/han-1034683568/p/8241369.html)\n- [阿里巴巴Java开发规约插件p3c详细教程及使用感受](http://www.cnblogs.com/han-1034683568/p/7682594.html)\n- [阿里官方Java代码规范标准《阿里巴巴Java开发手册 终极版 v1.3.0》下载](http://www.cnblogs.com/han-1034683568/p/7680354.html)\n- [程序员视角：鹿晗公布恋情是如何把微博搞炸的？](http://www.cnblogs.com/han-1034683568/p/7642213.html)\n- [could not resolve host: github.com 问题解决办法](http://www.cnblogs.com/han-1034683568/p/6457894.html)\n- [使用git恢复未提交的误删数据](http://www.cnblogs.com/han-1034683568/p/6444937.html)\n- [springboot开启access_log日志输出](http://www.cnblogs.com/han-1034683568/p/6963144.html)\n- [Error: Cannot find module \'gulp-clone\'问题的解决](http://www.cnblogs.com/han-1034683568/p/6479288.html)\n- [Markdown语法讲解及MWeb使用教程](http://www.cnblogs.com/han-1034683568/p/6556348.html)\n- [javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites are inappropriate)](http://www.cnblogs.com/han-1034683568/p/7009096.html)\n- [org.springframework.data.redis.serializer.SerializationException: Cannot serialize;](http://www.cnblogs.com/han-1034683568/p/7994322.html)\n\n<h2 id=\"13blog\">My Blog</h2>\n\n- [Docker+SpringBoot+Mybatis+thymeleaf的Java博客系统开源啦](http://www.cnblogs.com/han-1034683568/p/6840493.html)\n- [My-Blog搭建过程：如何让一个网站从零到可以上线访问](http://www.cnblogs.com/han-1034683568/p/6885545.html)\n- [将数据的初始化放到docker中的整个工作过程(问题记录)](http://www.cnblogs.com/han-1034683568/p/6941313.html)\n- [利用Dockerfile构建mysql镜像并实现数据的初始化及权限设置](http://www.cnblogs.com/han-1034683568/p/6941337.html)\n- [解决Docker容器时区及时间不同步的问题](http://www.cnblogs.com/han-1034683568/p/6957132.html)\n- [Java开源博客My-Blog之docker容器组件化修改](http://www.cnblogs.com/han-1034683568/p/7102765.html)\n- [运行shell脚本时报错\"\\[\\[ : not found\"解决方法](http://www.cnblogs.com/han-1034683568/p/7211392.html)\n- [shell脚本中字符串的常见操作及\"command not found\"报错处理(附源码)](http://www.cnblogs.com/han-1034683568/p/7217047.html)\n- [Java开源博客My-Blog之mysql容器重复初始化的严重bug修复过程](http://www.cnblogs.com/han-1034683568/p/7231895.html)\n- [Mybatis-Generator生成Mapper文件中if test=\"criteria.valid\"的问题解答](http://www.cnblogs.com/han-1034683568/p/7281474.html)\n- [Springboot与Thymeleaf模板引擎整合基础教程](http://www.cnblogs.com/han-1034683568/p/7520012.html)\n- [thymeleaf模板引擎调用java类中的方法](http://www.cnblogs.com/han-1034683568/p/7527564.html)\n\n<h2 id=\"message-attack\">短信接口攻击事件</h2>\n\n- [短信发送接口被恶意访问的网络攻击事件(一)紧张的遭遇战险胜](http://www.cnblogs.com/han-1034683568/p/6973269.html)\n- [短信发送接口被恶意访问的网络攻击事件(二)肉搏战-阻止恶意请求](http://www.cnblogs.com/han-1034683568/p/7001785.html)\n- [短信发送接口被恶意访问的网络攻击事件(三)定位恶意IP的日志分析脚本](http://www.cnblogs.com/han-1034683568/p/7040417.html)\n- [短信发送接口被恶意访问的网络攻击事件(四)完结篇--搭建WAF清理战场](http://www.cnblogs.com/han-1034683568/p/7090409.html)\n\n<h2 id=\"read\">读书笔记</h2>\n\n- [《实战java高并发程序设计》源码整理及读书笔记](http://www.cnblogs.com/han-1034683568/p/6918160.html)\n- [《大型网站技术架构:核心原理与案例分析》读书笔记](http://www.cnblogs.com/han-1034683568/p/7597564.html)\n- [大型网站技术架构(二)--大型网站架构演化](http://www.cnblogs.com/han-1034683568/p/8423447.html)\n- [大型网站技术架构(三)--架构模式](http://www.cnblogs.com/han-1034683568/p/8677349.html)\n- [大型网站技术架构(四)--核心架构要素](http://www.cnblogs.com/han-1034683568/p/9049758.html)\n\n<h2 id=\"ssm2\">SSM整合优化篇</h2>\n\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（一）System.out.print与Log](http://www.cnblogs.com/han-1034683568/p/6637914.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（二）Log4j讲解与整合](http://www.cnblogs.com/han-1034683568/p/6641808.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（三）代码测试](http://www.cnblogs.com/han-1034683568/p/6642306.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（四）单元测试实例](http://www.cnblogs.com/han-1034683568/p/6649077.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（五）结合MockMvc进行服务端的单元测试](http://www.cnblogs.com/han-1034683568/p/6653620.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（六）easyUI与富文本编辑器UEditor整合](http://www.cnblogs.com/han-1034683568/p/6664660.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（七）图片上传功能](http://www.cnblogs.com/han-1034683568/p/6692150.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（八）代码优化整理小记及个人吐槽](http://www.cnblogs.com/han-1034683568/p/6706158.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（九）数据层优化-jdbc连接池简述、druid简介](http://www.cnblogs.com/han-1034683568/p/6719298.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十）数据层优化-整合druid](http://www.cnblogs.com/han-1034683568/p/6725191.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十一）数据层优化-druid监控及慢sql记录](http://www.cnblogs.com/han-1034683568/p/6730869.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十二）数据层优化-explain关键字及慢sql优化](http://www.cnblogs.com/han-1034683568/p/6758578.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十三）数据层优化-表规范、索引优化](http://www.cnblogs.com/han-1034683568/p/6768807.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十四）谈谈写博客的原因和项目优化](http://www.cnblogs.com/han-1034683568/p/6782019.html)\n\n<h2 id=\"ssm1\">SSM整合基础篇</h2>\n\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（一）项目简述及技术选型介绍](http://www.cnblogs.com/han-1034683568/p/6440090.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（二）牛刀小试](http://www.cnblogs.com/han-1034683568/p/6440157.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（三）搭建步骤](http://www.cnblogs.com/han-1034683568/p/6476827.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（四）代码简化](http://www.cnblogs.com/han-1034683568/p/6476852.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（五）讲一下maven](http://www.cnblogs.com/han-1034683568/p/6486117.html)\n- [Maven构建项目速度太慢的解决办法](http://www.cnblogs.com/han-1034683568/p/6498637.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（六）maven整合SSM](http://www.cnblogs.com/han-1034683568/p/6507186.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（七）JDBC url的连接参数](http://www.cnblogs.com/han-1034683568/p/6512215.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（八）mysql中文查询bug修复](http://www.cnblogs.com/han-1034683568/p/6517344.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（九）版本控制](http://www.cnblogs.com/han-1034683568/p/6540079.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（十）SVN搭建](http://www.cnblogs.com/han-1034683568/p/6545751.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（十一）SVN服务器进阶](http://www.cnblogs.com/han-1034683568/p/6551498.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（十二）阶段总结](http://www.cnblogs.com/han-1034683568/p/6562092.html)',24,'日常随笔','目录',1,16,0,1,'2019-04-24 15:42:23','2019-04-24 15:42:23'),
(3,'Spring+SpringMVC+MyBatis整合系列(easyUI、AdminLte3)','','/admin/dist/img/rand/36.jpg','## 实战篇（付费教程）\n\n- [SSM 搭建精美实用的管理系统](http://gitbook.cn/m/mazi/comp/column?columnId=5b4dae389bcda53d07056bc9&sceneId=22778a708b0f11e8974b497483da0812)\n- [导读：自己动手实现 JavaWeb 后台管理系统](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4db47e9bcda53d07056f5f)\n- [第01课：Spring MVC+ Spring + Mybatis “三大框架”介绍](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4db5b89bcda53d070590de)\n- [第02课：前期准备工作及基础环境搭建](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4eb8e701d18a561f341b72)\n- [第03课：三大框架的整合](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4ee11c01d18a561f342c0f)\n- [第04课：Tomcat 8 安装部署及功能改造](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1335dbb1436093a6ca17)\n- [第05课：产品设计之搭建精美实用的后台管理系统](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b35dbb1436093a6cc7a)\n- [第06课：前端选型 AdminLTE3](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b70dbb1436093a6cc87)\n- [第07课：登录模块的系统设计和实现](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b80dbb1436093a6cc8e)\n- [第08课：使用 JqGrid 插件实现分页功能](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1b92dbb1436093a6cc93)\n- [第09课：弹框组件整合——完善添加和修改功能](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1bbddbb1436093a6cc9b)\n- [第10课：图片管理模块](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1bd0dbb1436093a6cca1)\n- [第11课：多图上传与大文件分片上传、断点续传](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1bdedbb1436093a6cca2)\n- [第12课：文件导入导出功能](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1beddbb1436093a6cca8)\n- [第13课：富文本信息管理模块](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c00dbb1436093a6ccae)\n- [第14课：SweetAlert 插件整合及搜索功能实现](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c11dbb1436093a6ccb1)\n- [第15课：项目发布——Linux 命令及发布流程](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c21dbb1436093a6ccb6)\n- [第16课：项目优化篇之日志输出](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c30dbb1436093a6ccbb)\n- [第17课：项目优化之单元测试](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c3fdbb1436093a6ccc1)\n- [第18课：项目优化之数据库连接池](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c50dbb1436093a6ccca)\n- [第19课：项目优化之 Druid 整合](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c65dbb1436093a6cccd)\n- [第20课：项目优化之缓存整合](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c7cdbb1436093a6ccd6)\n- [第21课：网站架构演进及 Nginx 介绍](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c8bdbb1436093a6ccda)\n- [第22课：Nginx + Tomcat 集群搭建](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1c9ddbb1436093a6cce2)\n- [第23课：Nginx 动静分离](https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9/topic/5b4f1cb7dbb1436093a6cceb)\n\n## 进阶篇（免费开源）\n\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（一）设计一套好的RESTful API](http://www.cnblogs.com/han-1034683568/p/7196345.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（二）RESTful API实战笔记(接口设计及Java后端实现)](http://www.cnblogs.com/han-1034683568/p/7300547.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（三）使用ajax方法实现form表单的提交](http://www.cnblogs.com/han-1034683568/p/7199168.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（四）RESTful实战(前端代码修改)](http://www.cnblogs.com/han-1034683568/p/7552007.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（五）记录一下从懵懂到理解RESTful的过程](http://www.cnblogs.com/han-1034683568/p/7569870.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（六）一定要RESTful吗？](http://www.cnblogs.com/han-1034683568/p/7663641.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（七）一次线上Mysql数据库崩溃事故的记录](http://www.cnblogs.com/han-1034683568/p/7787659.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（八）线上Mysql数据库崩溃事故的原因和处理](http://www.cnblogs.com/han-1034683568/p/7822237.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（九）Linux下安装redis及redis的常用命令和操作](http://www.cnblogs.com/han-1034683568/p/7862188.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十）easyUI整合KindEditor详细教程](http://www.cnblogs.com/han-1034683568/p/7930542.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十一）redis密码设置、安全设置](http://www.cnblogs.com/han-1034683568/p/7978577.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十二）Spring集成Redis缓存](http://www.cnblogs.com/han-1034683568/p/7994231.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十三）MyBatis+MySQL返回插入的主键id](http://www.cnblogs.com/han-1034683568/p/8305122.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十四）Redis正确的使用姿势](http://www.cnblogs.com/han-1034683568/p/8406497.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合进阶篇（十五）阶段总结](http://www.cnblogs.com/han-1034683568/p/9069008.html)\n\n\n## 优化篇（免费开源）\n\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（一）System.out.print与Log](http://www.cnblogs.com/han-1034683568/p/6637914.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（二）Log4j讲解与整合](http://www.cnblogs.com/han-1034683568/p/6641808.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（三）代码测试](http://www.cnblogs.com/han-1034683568/p/6642306.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（四）单元测试实例](http://www.cnblogs.com/han-1034683568/p/6649077.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（五）结合MockMvc进行服务端的单元测试](http://www.cnblogs.com/han-1034683568/p/6653620.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（六）easyUI与富文本编辑器UEditor整合](http://www.cnblogs.com/han-1034683568/p/6664660.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（七）图片上传功能](http://www.cnblogs.com/han-1034683568/p/6692150.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（八）代码优化整理小记及个人吐槽](http://www.cnblogs.com/han-1034683568/p/6706158.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（九）数据层优化-jdbc连接池简述、druid简介](http://www.cnblogs.com/han-1034683568/p/6719298.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十）数据层优化-整合druid](http://www.cnblogs.com/han-1034683568/p/6725191.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十一）数据层优化-druid监控及慢sql记录](http://www.cnblogs.com/han-1034683568/p/6730869.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十二）数据层优化-explain关键字及慢sql优化](http://www.cnblogs.com/han-1034683568/p/6758578.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十三）数据层优化-表规范、索引优化](http://www.cnblogs.com/han-1034683568/p/6768807.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合优化篇（十四）谈谈写博客的原因和项目优化](http://www.cnblogs.com/han-1034683568/p/6782019.html)\n\n\n## 基础篇（免费开源）\n\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（一）项目简介](http://www.cnblogs.com/han-1034683568/p/6440090.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（二）牛刀小试](http://www.cnblogs.com/han-1034683568/p/6440157.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（三）搭建步骤](http://www.cnblogs.com/han-1034683568/p/6476827.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（四）代码简化](http://www.cnblogs.com/han-1034683568/p/6476852.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（五）讲一下maven](http://www.cnblogs.com/han-1034683568/p/6486117.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（六）maven整合SSM](http://www.cnblogs.com/han-1034683568/p/6507186.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（七）JDBC url的连接参数](http://www.cnblogs.com/han-1034683568/p/6512215.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（八）mysql中文查询bug修复](http://www.cnblogs.com/han-1034683568/p/6517344.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（九）版本控制](http://www.cnblogs.com/han-1034683568/p/6540079.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（十）SVN搭建](http://www.cnblogs.com/han-1034683568/p/6545751.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（十一）SVN服务器进阶](http://www.cnblogs.com/han-1034683568/p/6551498.html)\n- [Spring+SpringMVC+MyBatis+easyUI整合基础篇（十二）阶段总结](http://www.cnblogs.com/han-1034683568/p/6562092.html)\n\n\n推荐一下自己的达人课，感兴趣的朋友可以看一下：[SSM搭建精美实用的管理系统](http://gitbook.cn/m/mazi/comp/column?columnId=5b4dae389bcda53d07056bc9&sceneId=22778a708b0f11e8974b497483da0812)',22,'SSM整合进阶篇','Spring,SpringMVC,MyBatis,easyUI,AdminLte3',1,58,0,1,'2019-04-24 15:46:15','2019-04-24 15:46:15'),
(4,'SpringBoot系列教程','','/admin/dist/img/rand/29.jpg','<h2 id=\"springboot2\">23 个实验带你轻松玩转 Spring Boot</h2>\n\n- [**开篇词：《23 个实验带你轻松玩转 Spring Boot》导读**](https://www.shiyanlou.com/courses/1274)\n- [第02课：Spring Boot 项目开发环境搭建](https://www.shiyanlou.com/courses/1274)\n- [第03课：快速构建 Spring Boot 应用](https://www.shiyanlou.com/courses/1274)\n- [第04课：Spring Boot 基础功能开发](https://www.shiyanlou.com/courses/1274)\n- [第05课：Spring Boot 项目开发之 web 项目开发讲解](https://www.shiyanlou.com/courses/1274)\n- [第06课：Spring Boot 整合 JSP 开发 web 项目](https://www.shiyanlou.com/courses/1274)\n- [第07课：模板引擎介绍及 Spring Boot 整合 Thymeleaf](https://www.shiyanlou.com/courses/1274)\n- [第08课：Thymeleaf 语法详解](https://www.shiyanlou.com/courses/1274)\n- [第09课：FreeMarker 模板引擎整合使用教程](https://www.shiyanlou.com/courses/1274)\n- [第10课：Spring Boot 处理文件上传及路径回显](https://www.shiyanlou.com/courses/1274)\n- [第11课：Spring Boot 自动配置数据源及操作数据库](https://www.shiyanlou.com/courses/1274)\n- [第12课：Spring Boot 整合 Druid 数据源](https://www.shiyanlou.com/courses/1274)\n- [第13课：Spring Boot 整合 MyBatis 操作数据库](https://www.shiyanlou.com/courses/1274)\n- [第14课：Spring Boot 中的事务处理](https://www.shiyanlou.com/courses/1274)\n- [第15课：Spring Boot 整合 Redis 操作缓存模块](https://www.shiyanlou.com/courses/1274)\n- [第16课：Spring Boot 项目开发之实现定时任务](https://www.shiyanlou.com/courses/1274)\n- [第17课：Spring Boot 自定义错误页面](https://www.shiyanlou.com/courses/1274)\n- [第18课：Spring Boot 集成 Swagger 生成接口文档](https://www.shiyanlou.com/courses/1274)\n- [第19课：Spring Boot 项目打包部署介绍](https://www.shiyanlou.com/courses/1274)\n- [第20课：Spring Boot Admin 介绍及整合使用](https://www.shiyanlou.com/courses/1274)\n- [第21课：Spring Boot 资讯管理信息系统开发实战(一)](https://www.shiyanlou.com/courses/1274)\n- [第22课：Spring Boot 资讯管理信息系统开发实战(二)](https://www.shiyanlou.com/courses/1274)\n- [第23课：Spring Boot 资讯管理信息系统开发实战(三)](https://www.shiyanlou.com/courses/1274)\n- [第24课：Spring Boot 资讯管理信息系统开发实战(四)](https://www.shiyanlou.com/courses/1274)\n\n<h2 id=\"springboot1\">Spring Boot 入门及前后端分离项目实践</h2>\n\n* [开篇词：SpringBoot入门及前后端分离项目实践导读](https://www.shiyanlou.com/courses/1244)\n* [第02课：快速认识 Spring Boot 技术栈](https://www.shiyanlou.com/courses/1244)\n* [第03课：开发环境搭建](https://www.shiyanlou.com/courses/1244)\n* [第04课：快速构建 Spring Boot 应用](https://www.shiyanlou.com/courses/1244)\n* [第05课：Spring Boot 之基础 web 功能开发](https://www.shiyanlou.com/courses/1244)\n* [第06课：Spring Boot 之数据库连接操作](https://www.shiyanlou.com/courses/1244)\n* [第07课：Spring Boot 整合 MyBatis 操作数据库](https://www.shiyanlou.com/courses/1244)\n* [第08课：Spring Boot 处理文件上传及路径回显](https://www.shiyanlou.com/courses/1244)\n* [第09课：Spring Boot 项目实践之前后端分离详解](https://www.shiyanlou.com/courses/1244)\n* [第10课：Spring Boot 项目实践之 API 设计](https://www.shiyanlou.com/courses/1244)\n* [第11课：Spring Boot 项目实践之登录模块实现](https://www.shiyanlou.com/courses/1244)\n* [第12课：Spring Boot 项目实践之分页功能实现](https://www.shiyanlou.com/courses/1244)\n* [第13课：Spring Boot 项目实践之jqgrid分页整合](https://www.shiyanlou.com/courses/1244)\n* [第14课：Spring Boot 项目实践之编辑功能实现](https://www.shiyanlou.com/courses/1244)\n* [第15课：Spring Boot 项目实践之用户管理模块实现](https://www.shiyanlou.com/courses/1244)\n* [第16课：Spring Boot 项目实践之图片管理模块](https://www.shiyanlou.com/courses/1244)\n* [第17课：Spring Boot 项目实践之富文本编辑器介绍及整合](https://www.shiyanlou.com/courses/1244)\n* [第18课：Spring Boot 项目实践之信息管理模块实现](https://www.shiyanlou.com/courses/1244)',24,'日常随笔','SpringBoot,入门教程,实战教程,spring-boot企业级开发',1,14,0,1,'2019-05-13 09:58:54','2019-05-13 09:58:54'),
(5,'【Core Java】第8章 泛型程序设计','','http://localhost:8083/admin/dist/img/rand/7.jpg','# 1 什么是泛型\nJava在1.5之后加入了泛型的概念。\n\n**泛型，即“参数化类型”。**\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。\n\n也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为**泛型类、泛型接口、泛型方法**。\n\n---\n# 2	为什么要使用泛型\n在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况 ，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。 \n\n**泛型的好处**：使用泛型，首先可以通过IDE进行代码类型初步检查，然后在编译阶段进行编译类型检查，以保证类型转换的安全性；并且所有的强制转换都是自动和隐式的，可以提高代码的重用率。\n\n# 3	泛型基础\nJava泛型有三种使用方式：泛型类、泛型方法、泛型接口。\n\n## 泛型类\n\n\n泛型类的语法如下：\n\n```\nclass 类名称 <泛型类型标识>{}\n```\n例子：\n\n    public class Generic<T> {\n        private T t;\n        public void set(T t) {\n            this.t = t; \n        }\n        public T get() { \n            return t;\n        }\n    }\n这样就能装入很多\n\n```\nGeneric<Integer> integerGeneric = new Generic<Integer>();\nGeneric<Double> doubleGeneric = new Generic<Double>();\nGeneric<String> stringGeneric = new Generic<String>();\n```\n\n## 泛型方法\n\n泛型方法的语法如下：\n\n```\n[作用域修饰符] <泛型类型标识> [返回类型] 方法名称(参数列表){}\n```\n例子：\n\n```\npublic class Util {\n    public static <K, V> boolean compare(Generic<K, V> g1, Generic<K, V> g2) {\n        return g1.getKey().equals(g2.getKey()) &&\n               g1.getValue().equals(g2.getValue());\n    }\n}\npublic class Generic<K, V> {\n    private K key;\n    private V value;\n    public Generic(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n    public void setKey(K key) { this.key = key; }\n    public void setValue(V value) { this.value = value; }\n    public K getKey()   { return key; }\n    public V getValue() { return value; }\n}\n```\n调用：\n\n```\nGeneric<Integer, String> g1 = new Generic<>(1, \"apple\");\nGeneric<Integer, String> g2 = new Generic<>(2, \"pear\");\nboolean same = Util.<Integer, String>compare(g1, g2);\n```\n在Java1.7之后，编译器可以通过type inference（类型推导），根据实参的类型自动推导出相应参数的类型，可以缩写成这样：\n\n```\nboolean same = Util.compare(g1, g2);\n```\n**例外**\n\n比如Double类型的，但是后面传进去一个Double，两个Integer，那么就会找这些类的共同超类，Number和Comparable接口，其本身也是一个泛型，这种情况下，补救措施就是所有参数都是double\n\n**类型变量的限定**\n\n```\n<T extends Class A, ClassB & InterfaceA, InterfaceB>\n```\n这里不管接口还是类都用**extends**，因为T表示绑定类型的子类型（subtype）\n\n\n## 泛型接口\n\n泛型接口的语法如下：\n\n```\npublic interface Generator<T> {\n    public T next();\n}\n```\n**当实现泛型接口的类，未给泛型传入实参时：**\n\n```\nclass FruitGenerator<T> implements Generator<T>{\n    @Override\n    public T next() {\n        return null;\n    }\n}\n```\n未传入泛型实参时，与泛型类的定义相同\n\n**在声明类的时候，需将泛型的声明也一起加到类中。**\n即：`class FruitGenerator<T> implements`。我们可以为T传入任意一种实参，形成无数种类型的Generator接口。\n如果不声明泛型，如：`class FruitGenerator implements Generator<T>`，编译器会报错：\"Unknown class\"。\n\n\n**当实现泛型接口的类，给泛型传入了实参时：**\n\n    public class FruitGenerator implements Generator<String> {\n    \n        private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n    \n        @Override\n        public String next() {\n            Random rand = new Random();\n            return fruits[rand.nextInt(3)];\n        }\n    }\n\n如果类已经将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型。即：Generator<T>，public T next();中的的T都要替换成传入的String类型。\n\n\n# 4	通配符\n用`Generic<Number>`作为形参的方法中，能否使用`Generic<Ingeter>`的实例传入呢？\n\n**不行！！！**\n\n这就尴尬了，和Java多态冲突。\n\n所以\n\n```\npublic void showKeyValue(Generic<?> obj){\n    System.out.println(\"泛型测试,value is \" + obj.get());\n}\n```\n这里`Generic<?>`是个无界通配符，任意类型都能传入\n\n## 泛型的上下边界\n\n**在Java泛型定义时:**\n用`<T>`等大写字母标识泛型类型，用于表示未知类型。\n用`<T extends ClassA & InterfaceB …>`等标识有界泛型，用于表示有边界的类型。\n\n**在Java泛型实例化时:**\n用`<?>`标识通配符，用于表示实例化时的类型。\n用`<? extends 父类型>`标识上边界通配符，用于表示实例化时可以确定父类型的类型。\n用`<? super 子类型>`标识下边界通配符，用于表示实例化时可以确定子类型的类型。\n对上面的Generic类增加一个新方法：\n\n```\npublic void showKeyValue1(Generic<? extends Number> obj){\n    System.out.println(\"泛型测试,value is \" + obj.get());\n}\n```\n表示是Number的一个子类泛型，可以是Number类，也可以是Number的子类\n\n```\nGeneric<String> generic1 = new Generic<String>(\"11111\");\nGeneric<Integer> generic2 = new Generic<Integer>(2222);\nGeneric<Float> generic3 = new Generic<Float>(2.4f);\nGeneric<Double> generic4 = new Generic<Double>(2.56);\n\n//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类\nshowKeyValue1(generic1);\n\nshowKeyValue1(generic2);\nshowKeyValue1(generic3);\nshowKeyValue1(generic4);\n```\n我们把泛型类的定义也修改\n\n```\npublic class Generic<T extends Number>{\n    private T key;\n\n    public Generic(T key) {\n        this.key = key;\n    }\n\n    public T getKey(){\n        return key;\n    }\n}\n```\n\n```\n//这一行代码也会报错，因为String不是Number的子类\nGeneric<String> generic1 = new Generic<String>(\"11111\");\n```\n泛型的上下边界添加，必须与泛型的声明在一起 。\n\n## PECS原则\n首先我们先定义几个简单的类，下面我们将用到它：\n\n    class Fruit {}\n    class Apple extends Fruit {}\n    class Orange extends Fruit {}\n\n然后定义一个主类：\n\n    public class Generics {\n        public static void main(String[] args) {\n            // 通过通配符申明一个List\n            List<? extends Fruit> flist = new ArrayList<Apple>();\n            // Compile Error: can\'t add any type of object:\n            // flist.add(new Apple())\n            // flist.add(new Orange())\n            // flist.add(new Fruit())\n            // flist.add(new Object())\n            flist.add(null); // Legal but uninteresting\n            // We Know that it returns at least Fruit:\n            Fruit f = flist.get(0);\n        }\n    }\n\n对于上面的flist，Java编译器不允许我们add任何对象，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为`List<? extends Fruit> flist`它自身可以有多种含义：\n\n    List<? extends Fruit> flist = new ArrayList<Fruit>();\n    List<? extends Fruit> flist = new ArrayList<Apple>();\n    List<? extends Fruit> flist = new ArrayList<Orange>();\n\n当我们尝试add一个Apple的时候，flist可能指向`new ArrayList<Orange>();`\n\n当我们尝试add一个Orange的时候，flist可能指向`new ArrayList<Apple>();`\n\n当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。\n\n**所以对于实现了`<? extends T>`的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。**\n\n如果我们要add元素应该怎么做呢？可以使用<? super T>：\n\n    public class GenericWriting {\n        static List<Apple> apples = new ArrayList<Apple>();\n        static List<Fruit> fruit = new ArrayList<Fruit>();\n        static <T> void writeExact(List<T> list, T item) {\n            list.add(item);\n        }\n        static void f1() {\n            writeExact(apples, new Apple());\n            writeExact(fruit, new Apple());\n        }\n        static <T> void writeWithWildcard(List<? super T> list, T item) {\n            list.add(item);\n        }\n        static void f2() {\n            writeWithWildcard(apples, new Apple());\n            writeWithWildcard(fruit, new Apple());\n        }\n        public static void main(String[] args) {\n            f1(); f2();\n        }\n    }\n\n这样我们可以往容器里面添加元素了，但是使用super后不能从容器里面get元素了，从编译器的角度考虑这个问题，对于`List<? super Apple> list`，它可以有下面几种含义：\n\n    List<? super Apple> list = new ArrayList<Apple>();\n    List<? super Apple> list = new ArrayList<Fruit>();\n    List<? super Apple> list = new ArrayList<Object>();\n\n当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。\n\n所以对于实现了`<? super T>`的集合类只能将它视为Consumer消费(add)元素，而不能作为Producer来对外获取(get)元素。\n在Java的集合类中，我们可以发现通常会将两者结合起来一起用，比如像下面这样：\n\n    public class Collections {\n        public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n            for (int i=0; i<src.size(); i++)\n                dest.set(i, src.get(i));\n        }\n    }\n**总结**\n`<? extends T>`只出不进\n`<? super T>`只进不出\n\n\n# 5 类型擦除\n类型擦除就是说Java泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，这样到了运行期间实际上JVM根本就知道泛型所代表的具体类型。这样做的目的是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。\n泛型擦除到底是什么，来看一个简单的例子：\n\n    public class Node<T> {\n        private T data;\n        private Node<T> next;\n        public Node(T data, Node<T> next) {\n            this.data = data;\n            this.next = next;\n        }\n        public T getData() { return data; }\n        // ...\n    }\n\n编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成：\n\n    public class Node {\n        private Object data;\n        private Node next;\n        public Node(Object data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n        public Object getData() { return data; }\n        // ...\n    }\n\n这意味着不管我们声明Node<String>还是`Node<Integer>`，到了运行期间，JVM统统视为`Node<Object>`。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置bounds了，将上面的代码修改成下面这样：\n\n    public class Node<T extends Comparable<T>> {\n        private T data;\n        private Node<T> next;\n        public Node(T data, Node<T> next) {\n            this.data = data;\n            this.next = next;\n        }\n        public T getData() { return data; }\n        // ...\n    }\n\n这样编译器就会将T出现的地方替换成Comparable而不再是默认的Object了：\n\n    public class Node {\n        private Comparable data;\n        private Node next;\n        public Node(Comparable data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n        public Comparable getData() { return data; }\n        // ...\n    }\n\n\n# 6	Java泛型使用限制\nJava泛型由于类型擦除的存在，会存在一些使用限制：\n\n## 1.Java泛型不能使用基本类型\n\n使用基本类型的泛型会编译报错，代码如下：\n\n    List<int> list = new List<int>();// 编译前类型检查报错\n\n## 2.Java泛型不允许进行直接实例化\n\n错误代码如下：\n\n    <T> void test(T t){\n        t = new T();//编译前类型检查报错\n    }\n    通过类型擦除，上面的泛型方法会转换为如下的原始方法：\n    \n    void test(Object t){\n        t = new Object();\n    }\n\n实例化的两种方法：\n\n**1. 通过集合来保存泛型对应的实例**\n\n    public class DbHelper {\n        private static final DbHelper instance;\n    \n        static {\n            instance = new DbHelper();\n        }\n    \n        private DbHelper() {\n        }\n    \n        private Map<Class<?>, ChangedListener> changedListeners = new HashMap<>();\n    \n        public <Model extends BaseModel> ChangedListener getListener(Class<Model> modelClass) {\n            if (changedListeners.containsKey(modelClass)) {\n                return changedListeners.get(modelClass);\n            }\n            return null;\n        }\n\n        public <Model extends BaseModel> void addChangedListener(final Class<Model> tClass,\n                                                                 ChangedListener<Model> listener) {\n            ChangedListener changedListener = getListener(tClass);\n            // 添加到中的Map\n            changedListeners.put(tClass, changedListener);\n        }\n    \n        public interface ChangedListener<Data extends BaseModel> {\n            void onDataSave(Data... list);\n    \n            void onDataDelete(Data... list);\n        }\n    }\n\n **2. 通过反射来实例化泛型类型**\n\n    public class GenericInstance {\n        public static <T> T createModelInstance(Class<T> tClass) {\n            try {\n                // 获取直接父类的类型Type\n                Type superClass = tClass.getGenericSuperclass();\n                // 调用getActualTypeArguments()方法获得实际绑定的类型\n                Type type = ((ParameterizedType) superClass).getActualTypeArguments()[0];\n                Class<?> clazz = getRawType(type);\n                return (T) clazz.newInstance();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n    \n        // type不能直接实例化对象，通过type获取class的类型，然后实例化对象\n        private static Class<?> getRawType(Type type) {\n            if (type instanceof Class) {\n                return (Class) type;\n            } else if (type instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType) type;\n                Type rawType = parameterizedType.getRawType();\n                return (Class) rawType;\n            } else if (type instanceof GenericArrayType) {\n                Type componentType = ((GenericArrayType) type).getGenericComponentType();\n                return Array.newInstance(getRawType(componentType), 0).getClass();\n            } else if (type instanceof TypeVariable) {\n                return Object.class;\n            } else if (type instanceof WildcardType) {\n                return getRawType(((WildcardType) type).getUpperBounds()[0]);\n            } else {\n                String className = type == null ? \"null\" : type.getClass().getName();\n                throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or GenericArrayType, but <\"\n                        + type + \"> is of type \" + className);\n            }\n        }\n    }\n\n为了防止此类类型转换错误的发生，Java禁止进行泛型实例化。\n\n## 3.Java泛型不允许进行静态化\n\n参考下面的代码：\n\n    class StaticGeneric<T>{\n            private static T t;// 编译前类型检查报错\n    \n            public static T getT() {// 编译前类型检查报错\n                return t;\n            }\n        }\n\n静态变量在类中共享，而泛型类型是不确定的，因此编译器无法确定要使用的类型，所以不允许进行静态化。\n\n## 4.Java泛型不允许直接进行类型转换（通配符可以）\n\n    List<Integer> integerList = new ArrayList<Integer>();\n    List<Double> doubleList = new ArrayList<Double>();\n    //不能直接进行类型转换，类型检查报错\n    integerList = doubleList;\n\n虽然在编译期间integerList与doubleList都会经过类型擦除，但是这种类型转换违反了Java泛型降低类型转换安全隐患的设计初衷。当integerList中存储Interge元素，而doubleList中存储Double元素时，如果不限制类型转换，很容易产生ClassCastException异常。\n但是通配符有可以实现：\n\n    <!--List<Integer> integerList = new ArrayList<Integer>();-->\n    <!--List<Double> doubleList = new ArrayList<Double>();-->\n    <!--//通过通配符进行类型转换-->\n    <!--doubleList = integerList;-->\n    static void cast(List<?> orgin, List<?> dest){\n        dest = orgin;\n    }\n\n## 5.Java泛型不允许直接使用instanceof运算符进行运行时类型检查（通配符可以）\n\n直接使用instanceof运算符进行运行时类型检查：\n\n    List<String> stringList = new ArrayList<String >();\n    //不能直接使用instanceof，类型检查报错\n    System.out.println(stringList instanceof ArrayList<Double>);\n\n因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出`ArrayList<Integer>`和`ArrayList<String>`的之间的区别。\n而我们可以通过通配符的方式进行instanceof运行期检查：\n\n    // 这个时候的类型检查没有意义\n    System.out.println(stringList instanceof ArrayList<?>);\n\n## 6.Java泛型不允许创建确切类型的泛型数组（通配符可以）\n\n创建整型泛型数组如下：\n\n    //类型检查错误\n    List<Integer>[] list = new ArrayList<Integer>[2];\n\n可以通过通配符创建：\n\n    Generic<?>[] generics = new Generic<?>[2];\n    generics[0] = new Generic<Integer>(123);\n    generics[1] = new Generic<String>(\"hello\");\n    for (Generic<?> generic : generics) {\n        System.out.println(generic.get());\n    }\n\n结果会正常打印出123和\"hello\"。\n\n## 7.Java泛型不允许作为参数进行重载\n\n例如：\n\n    public class GenericTest<T>{\n        void test(List<Integer> list){}\n        //不允许作为参数列表进行重载\n        void test(List<Double> list){}\n    }\n\n原因是：类型擦除后两个方法是一样的参数列表，无法重载。',26,'Java','Core Java',1,2,0,0,'2020-02-19 18:57:41','2020-02-19 18:57:41'),
(6,'【Core Java】第9章 集合','','http://localhost:8083/admin/dist/img/rand/7.jpg','# Java集合框架定义\n用java的类库帮我们在程序设计中实现传统的数据结构\n## 接口与实现分离\n使用接口类型存放集合的引用\n```java\nQuene<Customer> expressLane = new LinkedList<>();\n```\n```java\nQuene<Customer> expressLane = new CircularArrayQuene<>();\n```\n\n**循环数组**容量有限\n\n无限的话最好用**链表**\n\n以Abstract开头的类，例如AbstractQuene。如果要实现自己的队列类，扩展AbstractQuene比\n实现Quene接口要轻松\n\n## Collection接口\nCollections 工具类常用方法:\n\n排序\n查找,替换操作\n同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)\n排序操作\n\n```java\nvoid reverse(List list)//反转\nvoid shuffle(List list)//随机排序\nvoid sort(List list)//按自然排序的升序排序\nvoid sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)//交换两个索引位置的元素\nvoid rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。\n```\n示例代码:\n```java\n     ArrayList<Integer> arrayList = new ArrayList<Integer>();\n		arrayList.add(-1);\n		arrayList.add(3);\n		arrayList.add(3);\n		arrayList.add(-5);\n		arrayList.add(7);\n		arrayList.add(4);\n		arrayList.add(-9);\n		arrayList.add(-7);\n		System.out.println(\"原始数组:\");\n		System.out.println(arrayList);\n		// void reverse(List list)：反转\n		Collections.reverse(arrayList);\n		System.out.println(\"Collections.reverse(arrayList):\");\n		System.out.println(arrayList);\n\n\n		Collections.rotate(arrayList, 4);\n		System.out.println(\"Collections.rotate(arrayList, 4):\");\n		System.out.println(arrayList);\n\n		// void sort(List list),按自然排序的升序排序\n		Collections.sort(arrayList);\n		System.out.println(\"Collections.sort(arrayList):\");\n		System.out.println(arrayList);\n\n		// void shuffle(List list),随机排序\n		Collections.shuffle(arrayList);\n		System.out.println(\"Collections.shuffle(arrayList):\");\n		System.out.println(arrayList);\n\n		// void swap(List list, int i , int j),交换两个索引位置的元素\n		Collections.swap(arrayList, 2, 5);\n		System.out.println(\"Collections.swap(arrayList, 2, 5):\");\n		System.out.println(arrayList);\n\n		// 定制排序的用法\n		Collections.sort(arrayList, new Comparator<Integer>() {\n\n			@Override\n			public int compare(Integer o1, Integer o2) {\n				return o2.compareTo(o1);\n			}\n		});\n		System.out.println(\"定制排序后：\");\n		System.out.println(arrayList);\n```\n### 查找,替换操作\n\n```java\nint binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。\nint frequency(Collection c, Object o)//统计元素出现次数\nint indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).\nboolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素\n```\n\n**示例代码：**\n\n```java\n		ArrayList<Integer> arrayList = new ArrayList<Integer>();\n		arrayList.add(-1);\n		arrayList.add(3);\n		arrayList.add(3);\n		arrayList.add(-5);\n		arrayList.add(7);\n		arrayList.add(4);\n		arrayList.add(-9);\n		arrayList.add(-7);\n		ArrayList<Integer> arrayList2 = new ArrayList<Integer>();\n		arrayList2.add(-3);\n		arrayList2.add(-5);\n		arrayList2.add(7);\n		System.out.println(\"原始数组:\");\n		System.out.println(arrayList);\n\n		System.out.println(\"Collections.max(arrayList):\");\n		System.out.println(Collections.max(arrayList));\n\n		System.out.println(\"Collections.min(arrayList):\");\n		System.out.println(Collections.min(arrayList));\n\n		System.out.println(\"Collections.replaceAll(arrayList, 3, -3):\");\n		Collections.replaceAll(arrayList, 3, -3);\n		System.out.println(arrayList);\n\n		System.out.println(\"Collections.frequency(arrayList, -3):\");\n		System.out.println(Collections.frequency(arrayList, -3));\n\n		System.out.println(\"Collections.indexOfSubList(arrayList, arrayList2):\");\n		System.out.println(Collections.indexOfSubList(arrayList, arrayList2));\n\n		System.out.println(\"Collections.binarySearch(arrayList, 7):\");\n		// 对List进行二分查找，返回索引，List必须是有序的\n		Collections.sort(arrayList);\n		System.out.println(Collections.binarySearch(arrayList, 7));\n```\n\n### 同步控制\n\nCollections提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。\n\n我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。\n\n**最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。**\n\n方法如下：\n\n```java\nsynchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。\nsynchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。\nsynchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。\nsynchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。\n```\n\n### Collections还可以设置不可变集合，提供了如下三类方法：\n\n```java\nemptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。\nsingletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。\nunmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。\n上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。\n```\n\n**示例代码：**\n\n```java\n        ArrayList<Integer> arrayList = new ArrayList<Integer>();\n        arrayList.add(-1);\n        arrayList.add(3);\n        arrayList.add(3);\n        arrayList.add(-5);\n        arrayList.add(7);\n        arrayList.add(4);\n        arrayList.add(-9);\n        arrayList.add(-7);\n        HashSet<Integer> integers1 = new HashSet<>();\n        integers1.add(1);\n        integers1.add(3);\n        integers1.add(2);\n        Map scores = new HashMap();\n        scores.put(\"语文\" , 80);\n        scores.put(\"Java\" , 82);\n\n        //Collections.emptyXXX();创建一个空的、不可改变的XXX对象\n        List<Object> list = Collections.emptyList();\n        System.out.println(list);//[]\n        Set<Object> objects = Collections.emptySet();\n        System.out.println(objects);//[]\n        Map<Object, Object> objectObjectMap = Collections.emptyMap();\n        System.out.println(objectObjectMap);//{}\n\n        //Collections.singletonXXX();\n        List<ArrayList<Integer>> arrayLists = Collections.singletonList(arrayList);\n        System.out.println(arrayLists);//[[-1, 3, 3, -5, 7, 4, -9, -7]]\n        //创建一个只有一个元素，且不可改变的Set对象\n        Set<ArrayList<Integer>> singleton = Collections.singleton(arrayList);\n        System.out.println(singleton);//[[-1, 3, 3, -5, 7, 4, -9, -7]]\n        Map<String, String> nihao = Collections.singletonMap(\"1\", \"nihao\");\n        System.out.println(nihao);//{1=nihao}\n\n        //unmodifiableXXX();创建普通XXX对象对应的不可变版本\n        List<Integer> integers = Collections.unmodifiableList(arrayList);\n        System.out.println(integers);//[-1, 3, 3, -5, 7, 4, -9, -7]\n        Set<Integer> integers2 = Collections.unmodifiableSet(integers1);\n        System.out.println(integers2);//[1, 2, 3]\n        Map<Object, Object> objectObjectMap2 = Collections.unmodifiableMap(scores);\n        System.out.println(objectObjectMap2);//{Java=82, 语文=80}\n\n        //添加出现异常：java.lang.UnsupportedOperationException\n//        list.add(1);\n//        arrayLists.add(arrayList);\n//        integers.add(1);\n```\n\n## Arrays类的常见操作\n1. 排序 : `sort()`\n2. 查找 : `binarySearch()`\n3. 比较: `equals()`\n4. 填充 : `fill()`\n5. 转列表:  `asList()`\n6. 转字符串 : `toString()`\n7. 复制: `copyOf()`\n\n\n### 排序 : `sort()`\n\n```java\n		// *************排序 sort****************\n		int a[] = { 1, 3, 2, 7, 6, 5, 4, 9 };\n		// sort(int[] a)方法按照数字顺序排列指定的数组。\n		Arrays.sort(a);\n		System.out.println(\"Arrays.sort(a):\");\n		for (int i : a) {\n			System.out.print(i);\n		}\n		// 换行\n		System.out.println();\n\n		// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围\n		int b[] = { 1, 3, 2, 7, 6, 5, 4, 9 };\n		Arrays.sort(b, 2, 6);\n		System.out.println(\"Arrays.sort(b, 2, 6):\");\n		for (int i : b) {\n			System.out.print(i);\n		}\n		// 换行\n		System.out.println();\n\n		int c[] = { 1, 3, 2, 7, 6, 5, 4, 9 };\n		// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序\n		Arrays.parallelSort(c);\n		System.out.println(\"Arrays.parallelSort(c)：\");\n		for (int i : c) {\n			System.out.print(i);\n		}\n		// 换行\n		System.out.println();\n\n		// parallelSort给字符数组排序，sort也可以\n		char d[] = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\n		Arrays.parallelSort(d);\n		System.out.println(\"Arrays.parallelSort(d)：\");\n		for (char d2 : d) {\n			System.out.print(d2);\n		}\n		// 换行\n		System.out.println();\n\n```\n\n在做算法面试题的时候，我们还可能会经常遇到对字符串排序的情况,`Arrays.sort()` 对每个字符串的特定位置进行比较，然后按照升序排序。\n\n```java\nString[] strs = { \"abcdehg\", \"abcdefg\", \"abcdeag\" };\nArrays.sort(strs);\nSystem.out.println(Arrays.toString(strs));//[abcdeag, abcdefg, abcdehg]\n```\n\n### 查找 : `binarySearch()`\n\n```java\n		// *************查找 binarySearch()****************\n		char[] e = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\n		// 排序后再进行二分查找，否则找不到\n		Arrays.sort(e);\n		System.out.println(\"Arrays.sort(e)\" + Arrays.toString(e));\n		System.out.println(\"Arrays.binarySearch(e, \'c\')：\");\n		int s = Arrays.binarySearch(e, \'c\');\n		System.out.println(\"字符c在数组的位置：\" + s);\n```\n\n### 比较: `equals()`\n\n```java\n		// *************比较 equals****************\n		char[] e = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\n		char[] f = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\n		/*\n		* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。\n		*/\n		// 输出true\n		System.out.println(\"Arrays.equals(e, f):\" + Arrays.equals(e, f));\n```\n\n### 填充 : `fill()`\n\n```java\n		// *************填充fill(批量初始化)****************\n		int[] g = { 1, 2, 3, 3, 3, 3, 6, 6, 6 };\n		// 数组中所有元素重新分配值\n		Arrays.fill(g, 3);\n		System.out.println(\"Arrays.fill(g, 3)：\");\n		// 输出结果：333333333\n		for (int i : g) {\n			System.out.print(i);\n		}\n		// 换行\n		System.out.println();\n\n		int[] h = { 1, 2, 3, 3, 3, 3, 6, 6, 6, };\n		// 数组中指定范围元素重新分配值\n		Arrays.fill(h, 0, 2, 9);\n		System.out.println(\"Arrays.fill(h, 0, 2, 9);：\");\n		// 输出结果：993333666\n		for (int i : h) {\n			System.out.print(i);\n		}\n```\n\n### 转列表 `asList()`\n\n```java\n		// *************转列表 asList()****************\n		/*\n		 * 返回由指定数组支持的固定大小的列表。\n		 * （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。\n		 * 返回的列表是可序列化的，并实现RandomAccess 。\n		 * 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：\n		 */\n		List<String> stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n		System.out.println(stooges);\n```\n\n### 转字符串 `toString()`\n\n```java\n		// *************转字符串 toString()****************\n		/*\n		* 返回指定数组的内容的字符串表示形式。\n		*/\n		char[] k = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\n		System.out.println(Arrays.toString(k));// [a, f, b, c, e, A, C, B]\n```\n\n### 复制 `copyOf()`\n\n```java\n		// *************复制 copy****************\n		// copyOf 方法实现数组复制,h为数组，6为复制的长度\n		int[] h = { 1, 2, 3, 3, 3, 3, 6, 6, 6, };\n		int i[] = Arrays.copyOf(h, 6);\n		System.out.println(\"Arrays.copyOf(h, 6);：\");\n		// 输出结果：123333\n		for (int j : i) {\n			System.out.print(j);\n		}\n		// 换行\n		System.out.println();\n		// copyOfRange将指定数组的指定范围复制到新数组中\n		int j[] = Arrays.copyOfRange(h, 6, 11);\n		System.out.println(\"Arrays.copyOfRange(h, 6, 11)：\");\n		// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)\n		for (int j2 : j) {\n			System.out.print(j2);\n		}\n		// 换行\n		System.out.println();\n```\n## List,Set,Map三者的区别？\n\n - List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象 \n - Set(注重独一无二的性质):    不允许重复的集合。不会有多个元素引用相同的对象。 \n - Map(用Key来搜索的专家):      \n   使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。\n## Arraylist 与 LinkedList 区别?\n1. 是否保证线程安全： `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；\n\n2. 底层数据结构： `Arraylist` 底层使用的是 `Object` 数组；`LinkedList` 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n\n3. 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话`（add(int index, E element)）`时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。\n\n4. 是否支持快速随机访问： `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。**快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)方法)`。**\n\n5. 内存空间占用： `ArrayList`的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而`LinkedList`的空间花费则体现在它的每一个元素都需要消耗比`ArrayList`更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n## ArrayList 与 Vector 区别\n\n - `Vector`类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。\n - `Arraylist`不是同步的，所以在不需要保证线程安全时建议使用Arraylist。',26,'Java','Core Java',1,0,0,0,'2020-02-19 19:12:12','2020-02-19 19:12:12'),
(7,'【Core Java】第14章 并发','','http://localhost:8083/admin/dist/img/rand/7.jpg','进程和线程的本制区别在于每个进程拥有自己的一套变量，而线程共享数据\n\n\n## 什么是进程\n\n进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。\n\n在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，**而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。**\n\n## 什么是线程\n线程与进程相似，但线程是一个比进程更小的执行单位。\n\n一个进程在其执行的过程中可以产生多个线程。\n\n与进程不同的是同类的**多个线程共享进程的堆和方法区资源**，但**每个线程有自己的程序计数器、虚拟机栈和本地方法栈**。\n\n所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n\n下面，我们来看看Java为什么天生就是多线程程序\n\n```java\npublic class MultiThread {\n	public static void main(String[] args) {\n		// 获取 Java 线程管理 MXBean\n	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息\n		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n		// 遍历线程信息，仅打印线程 ID 和线程名称信息\n		for (ThreadInfo threadInfo : threadInfos) {\n			System.out.println(\"[\" + threadInfo.getThreadId() + \"] \" + threadInfo.getThreadName());\n		}\n	}\n}\n```\n\n结果为\n\n```java\n[5] Attach Listener //添加事件\n[4] Signal Dispatcher // 分发处理给 JVM 信号的线程\n[3] Finalizer //调用对象 finalize 方法的线程\n[2] Reference Handler //清除 reference 线程\n[1] main //main 线程,程序入口\n```\n\n所以，java程序是main线程和多个其他线程同时运行。\n\n\n## 从 JVM 角度说进程和线程之间的关系（重要）\n###  图解进程和线程的关系\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png\" width=\"600px\"/>\n</div>\n\n\n从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\n\n###  程序计数器为什么是私有的?\n\n程序计数器主要有下面两个作用：\n\n 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n \n需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n**所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。**\n\n###  虚拟机栈和本地方法栈为什么是私有的?\n**虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n**本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n所以，为了保证线程中的**局部变量**不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\n\n\n###  一句话简单了解堆和方法区\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n### 并发与并行概念解读\n**并发：**  同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；\n**并行：** 单位时间内，多个任务同时执行。\n\n\n## 具体怎么创建和运行\n有三种方法，继承Thread类，实现Runable接口，还有就是用线程池。',26,'Java','Core Java',1,1,0,0,'2020-02-19 19:15:12','2020-02-19 19:15:12'),
(8,'Servlet 、 HTTP协议 、Request总结','','http://localhost:8083/admin/dist/img/rand/6.jpg','# 今日内容：\n	1. Servlet\n	2. HTTP协议\n	3. Request\n\n\n\n\n## Servlet：\n	1. 概念\n	2. 步骤\n	3. 执行原理\n	4. 生命周期\n	5. Servlet3.0 注解配置\n	6. Servlet的体系结构	\n		Servlet -- 接口\n			|\n		GenericServlet -- 抽象类\n			|\n		HttpServlet  -- 抽象类\n\n		* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象\n			* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可\n\n		* HttpServlet：对http协议的一种封装，简化操作\n			1. 定义类继承HttpServlet\n			2. 复写doGet/doPost方法\n	\n	7. Servlet相关配置\n		1. urlpartten:Servlet访问路径\n			1. 一个Servlet可以定义多个访问路径 ： @WebServlet({\"/d4\",\"/dd4\",\"/ddd4\"})\n			2. 路径定义规则：\n				1. /xxx：路径匹配\n				2. /xxx/xxx:多层路径，目录结构\n				3. *.do：扩展名匹配\n\n## HTTP：\n	* 概念：Hyper Text Transfer Protocol 超文本传输协议\n		* 传输协议：定义了，客户端和服务器端通信时，发送数据的格式\n		* 特点：\n			1. 基于TCP/IP的高级协议\n			2. 默认端口号:80\n			3. 基于请求/响应模型的:一次请求对应一次响应\n			4. 无状态的：每次请求之间相互独立，不能交互数据\n\n		* 历史版本：\n			* 1.0：每一次请求响应都会建立新的连接\n			* 1.1：复用连接\n\n	* 请求消息数据格式\n		1. 请求行\n			请求方式 请求url 请求协议/版本\n			GET /login.html	HTTP/1.1\n\n			* 请求方式：\n				* HTTP协议有7中请求方式，常用的有2种\n					* GET：\n						1. 请求参数在请求行中，在url后。\n						2. 请求的url长度有限制的\n						3. 不太安全\n					* POST：\n						1. 请求参数在请求体中\n						2. 请求的url长度没有限制的\n						3. 相对安全\n		2. 请求头：客户端浏览器告诉服务器一些信息\n			请求头名称: 请求头值\n			* 常见的请求头：\n				1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息\n					* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题\n\n				2. Referer：http://localhost/login.html\n					* 告诉服务器，我(当前请求)从哪里来？\n						* 作用：\n							1. 防盗链：\n							2. 统计工作：\n		3. 请求空行\n			空行，就是用于分割POST请求的请求头，和请求体的。\n		4. 请求体(正文)：\n			* 封装POST请求消息的请求参数的\n\n		* 字符串格式：\n			POST /login.html	HTTP/1.1\n			Host: localhost\n			User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0\n			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n			Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\n			Accept-Encoding: gzip, deflate\n			Referer: http://localhost/login.html\n			Connection: keep-alive\n			Upgrade-Insecure-Requests: 1\n			\n			username=zhangsan	\n\n\n	* 响应消息数据格式\n\n\n\n\n## Request：\n	1. request对象和response对象的原理\n		1. request和response对象是由服务器创建的。我们来使用它们\n		2. request对象是来获取请求消息，response对象是来设置响应消息\n	\n	2. request对象继承体系结构：	\n		ServletRequest		--	接口\n			|	继承\n		HttpServletRequest	-- 接口\n			|	实现\n		org.apache.catalina.connector.RequestFacade 类(tomcat)\n\n	3. request功能：\n		1. 获取请求消息数据\n			1. 获取请求行数据\n				* GET /day14/demo1?name=zhangsan HTTP/1.1\n				* 方法：\n					1. 获取请求方式 ：GET\n						* String getMethod()  \n					2. (*)获取虚拟目录：/day14\n						* String getContextPath()\n					3. 获取Servlet路径: /demo1\n						* String getServletPath()\n					4. 获取get方式请求参数：name=zhangsan\n						* String getQueryString()\n					5. (*)获取请求URI：/day14/demo1\n						* String getRequestURI():		/day14/demo1\n						* StringBuffer getRequestURL()  :http://localhost/day14/demo1\n\n						* URL:统一资源定位符 ： http://localhost/day14/demo1	中华人民共和国\n						* URI：统一资源标识符 : /day14/demo1					共和国\n					\n					6. 获取协议及版本：HTTP/1.1\n						* String getProtocol()\n\n					7. 获取客户机的IP地址：\n						* String getRemoteAddr()\n					\n			2. 获取请求头数据\n				* 方法：\n					* (*)String getHeader(String name):通过请求头的名称获取请求头的值\n					* Enumeration<String> getHeaderNames():获取所有的请求头名称\n				\n			3. 获取请求体数据:\n				* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数\n				* 步骤：\n					1. 获取流对象\n						*  BufferedReader getReader()：获取字符输入流，只能操作字符数据\n						*  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据\n							* 在文件上传知识点后讲解\n\n					2. 再从流对象中拿数据\n				\n				\n		2. 其他功能：\n			1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数\n				1. String getParameter(String name):根据参数名称获取参数值    username=zs&password=123\n				2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&hobby=game\n				3. Enumeration<String> getParameterNames():获取所有请求的参数名称\n				4. Map<String,String[]> getParameterMap():获取所有参数的map集合\n\n				* 中文乱码问题：\n					* get方式：tomcat 8 已经将get方式乱码问题解决了\n					* post方式：会乱码\n						* 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\");\n			\n					\n			2. 请求转发：一种在服务器内部的资源跳转方式\n				1. 步骤：\n					1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)\n					2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) \n\n				2. 特点：\n					1. 浏览器地址栏路径不发生变化\n					2. 只能转发到当前服务器内部资源中。\n					3. 转发是一次请求\n\n\n			3. 共享数据：\n				* 域对象：一个有作用范围的对象，可以在范围内共享数据\n				* request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据\n				* 方法：\n					1. void setAttribute(String name,Object obj):存储数据\n					2. Object getAttitude(String name):通过键获取值\n					3. void removeAttribute(String name):通过键移除键值对\n\n			4. 获取ServletContext：\n				* ServletContext getServletContext()\n			\n\n\n\n## 案例：用户登录\n	* 用户登录案例需求：\n		1.编写login.html登录页面\n			username & password 两个输入框\n		2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表\n		3.使用JdbcTemplate技术封装JDBC\n		4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您\n		5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误\n\n\n	* 分析\n\n	* 开发步骤\n		1. 创建项目，导入html页面，配置文件，jar包\n		2. 创建数据库环境\n			CREATE DATABASE day14;\n			USE day14;\n			CREATE TABLE USER(\n			\n				id INT PRIMARY KEY AUTO_INCREMENT,\n				username VARCHAR(32) UNIQUE NOT NULL,\n				PASSWORD VARCHAR(32) NOT NULL\n			);\n\n		3. 创建包cn.itcast.domain,创建类User\n			package cn.itcast.domain;\n			/**\n			 * 用户的实体类\n			 */\n			public class User {\n			\n			    private int id;\n			    private String username;\n			    private String password;\n			\n			\n			    public int getId() {\n			        return id;\n			    }\n			\n			    public void setId(int id) {\n			        this.id = id;\n			    }\n			\n			    public String getUsername() {\n			        return username;\n			    }\n			\n			    public void setUsername(String username) {\n			        this.username = username;\n			    }\n			\n			    public String getPassword() {\n			        return password;\n			    }\n			\n			    public void setPassword(String password) {\n			        this.password = password;\n			    }\n			\n			    @Override\n			    public String toString() {\n			        return \"User{\" +\n			                \"id=\" + id +\n			                \", username=\'\" + username + \'\\\'\' +\n			                \", password=\'\" + password + \'\\\'\' +\n			                \'}\';\n			    }\n			}\n		4. 创建包cn.itcast.util,编写工具类JDBCUtils\n			package cn.itcast.util;\n\n			import com.alibaba.druid.pool.DruidDataSourceFactory;\n			\n			import javax.sql.DataSource;\n			import javax.xml.crypto.Data;\n			import java.io.IOException;\n			import java.io.InputStream;\n			import java.sql.Connection;\n			import java.sql.SQLException;\n			import java.util.Properties;\n			\n			/**\n			 * JDBC工具类 使用Durid连接池\n			 */\n			public class JDBCUtils {\n			\n			    private static DataSource ds ;\n			\n			    static {\n			\n			        try {\n			            //1.加载配置文件\n			            Properties pro = new Properties();\n			            //使用ClassLoader加载配置文件，获取字节输入流\n			            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n			            pro.load(is);\n			\n			            //2.初始化连接池对象\n			            ds = DruidDataSourceFactory.createDataSource(pro);\n			\n			        } catch (IOException e) {\n			            e.printStackTrace();\n			        } catch (Exception e) {\n			            e.printStackTrace();\n			        }\n			    }\n			\n			    /**\n			     * 获取连接池对象\n			     */\n			    public static DataSource getDataSource(){\n			        return ds;\n			    }\n			\n			\n			    /**\n			     * 获取连接Connection对象\n			     */\n			    public static Connection getConnection() throws SQLException {\n			        return  ds.getConnection();\n			    }\n			}\n		5. 创建包cn.itcast.dao,创建类UserDao,提供login方法\n			\n			package cn.itcast.dao;\n\n			import cn.itcast.domain.User;\n			import cn.itcast.util.JDBCUtils;\n			import org.springframework.dao.DataAccessException;\n			import org.springframework.jdbc.core.BeanPropertyRowMapper;\n			import org.springframework.jdbc.core.JdbcTemplate;\n			\n			/**\n			 * 操作数据库中User表的类\n			 */\n			public class UserDao {\n			\n			    //声明JDBCTemplate对象共用\n			    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\n			\n			    /**\n			     * 登录方法\n			     * @param loginUser 只有用户名和密码\n			     * @return user包含用户全部数据,没有查询到，返回null\n			     */\n			    public User login(User loginUser){\n			        try {\n			            //1.编写sql\n			            String sql = \"select * from user where username = ? and password = ?\";\n			            //2.调用query方法\n			            User user = template.queryForObject(sql,\n			                    new BeanPropertyRowMapper<User>(User.class),\n			                    loginUser.getUsername(), loginUser.getPassword());\n			\n			\n			            return user;\n			        } catch (DataAccessException e) {\n			            e.printStackTrace();//记录日志\n			            return null;\n			        }\n			    }\n			}\n		\n		6. 编写cn.itcast.web.servlet.LoginServlet类\n			package cn.itcast.web.servlet;\n\n			import cn.itcast.dao.UserDao;\n			import cn.itcast.domain.User;\n			\n			import javax.servlet.ServletException;\n			import javax.servlet.annotation.WebServlet;\n			import javax.servlet.http.HttpServlet;\n			import javax.servlet.http.HttpServletRequest;\n			import javax.servlet.http.HttpServletResponse;\n			import java.io.IOException;\n			\n			\n			@WebServlet(\"/loginServlet\")\n			public class LoginServlet extends HttpServlet {\n			\n			\n			    @Override\n			    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n			        //1.设置编码\n			        req.setCharacterEncoding(\"utf-8\");\n			        //2.获取请求参数\n			        String username = req.getParameter(\"username\");\n			        String password = req.getParameter(\"password\");\n			        //3.封装user对象\n			        User loginUser = new User();\n			        loginUser.setUsername(username);\n			        loginUser.setPassword(password);\n			\n			        //4.调用UserDao的login方法\n			        UserDao dao = new UserDao();\n			        User user = dao.login(loginUser);\n			\n			        //5.判断user\n			        if(user == null){\n			            //登录失败\n			            req.getRequestDispatcher(\"/failServlet\").forward(req,resp);\n			        }else{\n			            //登录成功\n			            //存储数据\n			            req.setAttribute(\"user\",user);\n			            //转发\n			            req.getRequestDispatcher(\"/successServlet\").forward(req,resp);\n			        }\n			\n			    }\n			\n			    @Override\n			    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n			        this.doGet(req,resp);\n			    }\n			}\n\n		7. 编写FailServlet和SuccessServlet类\n			@WebServlet(\"/successServlet\")\n			public class SuccessServlet extends HttpServlet {\n			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n			        //获取request域中共享的user对象\n			        User user = (User) request.getAttribute(\"user\");\n			\n			        if(user != null){\n			            //给页面写一句话\n			\n			            //设置编码\n			            response.setContentType(\"text/html;charset=utf-8\");\n			            //输出\n			            response.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\");\n			        }\n			\n			\n			    }		\n\n\n			@WebServlet(\"/failServlet\")\n			public class FailServlet extends HttpServlet {\n			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n			        //给页面写一句话\n			\n			        //设置编码\n			        response.setContentType(\"text/html;charset=utf-8\");\n			        //输出\n			        response.getWriter().write(\"登录失败，用户名或密码错误\");\n			\n			    }\n			\n			    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n			        this.doPost(request,response);\n			    }\n			}\n\n\n\n		8. login.html中form表单的action路径的写法\n			* 虚拟目录+Servlet的资源路径\n\n		9. BeanUtils工具类，简化数据封装\n			* 用于封装JavaBean的\n			1. JavaBean：标准的Java类\n				1. 要求：\n					1. 类必须被public修饰\n					2. 必须提供空参的构造器\n					3. 成员变量必须使用private修饰\n					4. 提供公共setter和getter方法\n				2. 功能：封装数据\n\n\n			2. 概念：\n				成员变量：\n				属性：setter和getter方法截取后的产物\n					例如：getUsername() --> Username--> username\n\n\n			3. 方法：\n				1. setProperty()\n				2. getProperty()\n				3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中',26,'Java','Servlet,HTTP,Request',1,1,0,0,'2020-02-19 19:16:47','2020-02-19 19:16:47');

/*Table structure for table `tb_blog_category` */

DROP TABLE IF EXISTS `tb_blog_category`;

CREATE TABLE `tb_blog_category` (
  `category_id` int NOT NULL AUTO_INCREMENT COMMENT '分类表主键',
  `category_name` varchar(50) NOT NULL COMMENT '分类的名称',
  `category_icon` varchar(50) NOT NULL COMMENT '分类的图标',
  `category_rank` int NOT NULL DEFAULT '1' COMMENT '分类的排序值 被使用的越多数值越大',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

/*Data for the table `tb_blog_category` */

insert  into `tb_blog_category`(`category_id`,`category_name`,`category_icon`,`category_rank`,`is_deleted`,`create_time`) values 
(20,'About','/admin/dist/img/category/10.png',11,0,'2018-11-12 00:28:49'),
(22,'SSM整合进阶篇','/admin/dist/img/category/02.png',20,1,'2018-11-12 10:42:25'),
(24,'日常随笔','/admin/dist/img/category/06.png',22,0,'2018-11-12 10:43:21'),
(25,'产品经理','/admin/dist/img/category/00.png',1,0,'2020-02-10 21:57:56'),
(26,'Java','/admin/dist/img/category/02.png',5,0,'2020-02-19 18:58:23');

/*Table structure for table `tb_blog_comment` */

DROP TABLE IF EXISTS `tb_blog_comment`;

CREATE TABLE `tb_blog_comment` (
  `comment_id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blog_id` bigint NOT NULL DEFAULT '0' COMMENT '关联的blog主键',
  `commentator` varchar(50) NOT NULL DEFAULT '' COMMENT '评论者名称',
  `email` varchar(100) NOT NULL DEFAULT '' COMMENT '评论人的邮箱',
  `website_url` varchar(50) NOT NULL DEFAULT '' COMMENT '网址',
  `comment_body` varchar(200) NOT NULL DEFAULT '' COMMENT '评论内容',
  `comment_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '评论提交时间',
  `commentator_ip` varchar(20) NOT NULL DEFAULT '' COMMENT '评论时的ip地址',
  `reply_body` varchar(200) NOT NULL DEFAULT '' COMMENT '回复内容',
  `reply_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '回复时间',
  `comment_status` tinyint NOT NULL DEFAULT '0' COMMENT '是否审核通过 0-未审核 1-审核通过',
  `is_deleted` tinyint DEFAULT '0' COMMENT '是否删除 0-未删除 1-已删除',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

/*Data for the table `tb_blog_comment` */

insert  into `tb_blog_comment`(`comment_id`,`blog_id`,`commentator`,`email`,`website_url`,`comment_body`,`comment_create_time`,`commentator_ip`,`reply_body`,`reply_create_time`,`comment_status`,`is_deleted`) values 
(26,4,'李志豪','448635854@qq.com','','第一条评论','2019-05-13 10:12:19','','','2019-05-12 21:13:31',1,0);

/*Table structure for table `tb_blog_tag` */

DROP TABLE IF EXISTS `tb_blog_tag`;

CREATE TABLE `tb_blog_tag` (
  `tag_id` int NOT NULL AUTO_INCREMENT COMMENT '标签表主键id',
  `tag_name` varchar(100) NOT NULL COMMENT '标签名称',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=139 DEFAULT CHARSET=utf8;

/*Data for the table `tb_blog_tag` */

insert  into `tb_blog_tag`(`tag_id`,`tag_name`,`is_deleted`,`create_time`) values 
(57,'世界上有一个很可爱的人',0,'2018-11-12 00:31:15'),
(58,'现在这个人就在看这句话',0,'2018-11-12 00:31:15'),
(66,'Spring',0,'2018-11-12 10:55:14'),
(67,'SpringMVC',0,'2018-11-12 10:55:14'),
(68,'MyBatis',0,'2018-11-12 10:55:14'),
(69,'easyUI',0,'2018-11-12 10:55:14'),
(127,'目录',0,'2019-04-24 15:41:39'),
(128,'AdminLte3',0,'2019-04-24 15:46:16'),
(130,'SpringBoot',0,'2019-05-13 09:58:54'),
(131,'入门教程',0,'2019-05-13 09:58:54'),
(132,'实战教程',0,'2019-05-13 09:58:54'),
(133,'spring-boot企业级开发',0,'2019-05-13 09:58:54'),
(134,'产品经理',0,'2020-02-10 22:37:24'),
(135,'Core Java',0,'2020-02-19 18:57:41'),
(136,'Servlet',0,'2020-02-19 19:16:47'),
(137,'HTTP',0,'2020-02-19 19:16:47'),
(138,'Request',0,'2020-02-19 19:16:47');

/*Table structure for table `tb_blog_tag_relation` */

DROP TABLE IF EXISTS `tb_blog_tag_relation`;

CREATE TABLE `tb_blog_tag_relation` (
  `relation_id` bigint NOT NULL AUTO_INCREMENT COMMENT '关系表id',
  `blog_id` bigint NOT NULL COMMENT '博客id',
  `tag_id` int NOT NULL COMMENT '标签id',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`relation_id`)
) ENGINE=InnoDB AUTO_INCREMENT=292 DEFAULT CHARSET=utf8;

/*Data for the table `tb_blog_tag_relation` */

insert  into `tb_blog_tag_relation`(`relation_id`,`blog_id`,`tag_id`,`create_time`) values 
(269,2,127,'2019-05-13 09:56:49'),
(270,4,130,'2019-05-13 09:58:54'),
(271,4,131,'2019-05-13 09:58:54'),
(272,4,132,'2019-05-13 09:58:54'),
(273,4,133,'2019-05-13 09:58:54'),
(274,3,66,'2019-05-13 10:07:27'),
(275,3,67,'2019-05-13 10:07:27'),
(276,3,68,'2019-05-13 10:07:27'),
(277,3,69,'2019-05-13 10:07:27'),
(278,3,128,'2019-05-13 10:07:27'),
(284,5,135,'2020-02-19 18:58:40'),
(285,6,135,'2020-02-19 19:12:12'),
(286,7,135,'2020-02-19 19:15:12'),
(287,8,136,'2020-02-19 19:16:47'),
(288,8,137,'2020-02-19 19:16:47'),
(289,8,138,'2020-02-19 19:16:47'),
(290,1,57,'2020-02-19 19:20:46'),
(291,1,58,'2020-02-19 19:20:46');

/*Table structure for table `tb_config` */

DROP TABLE IF EXISTS `tb_config`;

CREATE TABLE `tb_config` (
  `config_name` varchar(100) NOT NULL DEFAULT '' COMMENT '配置项的名称',
  `config_value` varchar(200) NOT NULL DEFAULT '' COMMENT '配置项的值',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`config_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `tb_config` */

insert  into `tb_config`(`config_name`,`config_value`,`create_time`,`update_time`) values 
('footerAbout','李志豪的个人网站','2018-11-11 20:33:23','2020-02-07 14:35:23'),
('footerCopyRight','2019-2020 Codelizh','2018-11-11 20:33:31','2020-02-07 14:35:23'),
('footerICP','浙ICP备XXXXXXXXX号','2018-11-11 20:33:27','2020-02-07 14:35:23'),
('footerPoweredBy','https://github.com/lizh960314','2018-11-11 20:33:36','2020-02-07 14:35:23'),
('footerPoweredByURL','https://github.com/lizh960314','2018-11-11 20:33:39','2020-02-07 14:35:23'),
('websiteDescription','personal blog是SpringBoot+Thymeleaf+Mybatis建造的个人博客网站.SpringBoot实战博客源码.个人博客搭建','2018-11-11 20:33:04','2020-02-07 14:34:57'),
('websiteIcon','/admin/dist/img/13.png','2018-11-11 20:33:11','2020-02-07 14:34:57'),
('websiteLogo','/admin/dist/img/logo.png','2018-11-11 20:33:08','2020-02-07 14:34:57'),
('websiteName','Codelizh Blog','2018-11-11 20:33:01','2020-02-07 14:34:57'),
('yourAvatar','/admin/dist/img/13.png','2018-11-11 20:33:14','2019-05-07 21:56:23'),
('yourEmail','448635854@qq.com','2018-11-11 20:33:17','2019-05-07 21:56:23'),
('yourName','李志豪','2018-11-11 20:33:20','2019-05-07 21:56:23');

/*Table structure for table `tb_link` */

DROP TABLE IF EXISTS `tb_link`;

CREATE TABLE `tb_link` (
  `link_id` int NOT NULL AUTO_INCREMENT COMMENT '友链表主键id',
  `link_type` tinyint NOT NULL DEFAULT '0' COMMENT '友链类别 0-友链 1-推荐 2-个人网站',
  `link_name` varchar(50) NOT NULL COMMENT '网站名称',
  `link_url` varchar(100) NOT NULL COMMENT '网站链接',
  `link_description` varchar(100) NOT NULL COMMENT '网站描述',
  `link_rank` int NOT NULL DEFAULT '0' COMMENT '用于列表排序',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0-未删除 1-已删除',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`link_id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

/*Data for the table `tb_link` */

insert  into `tb_link`(`link_id`,`link_type`,`link_name`,`link_url`,`link_description`,`link_rank`,`is_deleted`,`create_time`) values 
(1,0,'tqr','rqwe','rqw',0,1,'2018-10-22 18:57:52'),
(2,2,'志豪的GitHub','https://github.com/lizh960314','志豪分享代码的地方',1,0,'2018-10-22 19:41:04'),
(3,2,'志豪的博客','http://codelizh.cn','志豪的个人独立博客',14,0,'2018-10-22 19:53:34'),
(4,1,'CSDN 图文课','https://gitchat.csdn.net','IT优质内容平台',6,0,'2018-10-22 19:55:55'),
(5,2,'十三的博客园','https://www.cnblogs.com/han-1034683568','最开始写博客的地方',17,1,'2018-10-22 19:56:14'),
(6,1,'CSDN','https://www.csdn.net/','CSDN-专业IT技术社区官网',4,0,'2018-10-22 19:56:47'),
(7,0,'梁桂钊的博客','http://blog.720ui.com','后端攻城狮',1,1,'2018-10-22 20:01:38'),
(8,0,'猿天地','http://cxytiandi.com','一个综合性的网站,以程序猿用户为主,提供各种开发相关的内容',12,1,'2018-10-22 20:02:41'),
(9,0,'Giraffe Home','https://yemengying.com/','Giraffe Home',0,1,'2018-10-22 20:27:04'),
(10,0,'纯洁的微笑','http://www.ityouknow.com','分享技术，分享生活',3,1,'2018-10-22 20:27:16'),
(11,0,'afsdf','http://localhost:28080/admin/links','fad',0,1,'2018-10-22 20:27:26'),
(12,1,'afsdf','http://localhost','fad1',0,1,'2018-10-24 14:04:18'),
(13,0,'郭赵晖','http://guozh.net/','老郭三分地',0,1,'2019-04-24 15:30:19'),
(14,0,'dalaoyang','https://www.dalaoyang.cn/','dalaoyang',0,1,'2019-04-24 15:31:50'),
(15,0,'mushblog','https://www.sansani.cn','穆世明博客',0,1,'2019-04-24 15:32:19'),
(16,1,'实验楼','https://www.shiyanlou.com/','一家专注于IT技术的在线实训平台',17,0,'2019-04-24 16:03:48'),
(17,2,'《SSM 搭建精美实用的管理系统》','https://gitbook.cn/gitchat/column/5b4dae389bcda53d07056bc9','Spring+SpringMVC+MyBatis实战课程',18,1,'2019-04-24 16:06:52'),
(18,2,'《Spring Boot 入门及前后端分离项目实践》','https://www.shiyanlou.com/courses/1244','SpringBoot实战课程',19,1,'2019-04-24 16:07:27'),
(19,2,'《玩转Spring Boot 系列》','https://www.shiyanlou.com/courses/1274','SpringBoot实战课程',20,1,'2019-04-24 16:10:30'),
(20,0,'Stackflow','https://stackoverflow.com/','开发人员学习，共享和建立职业的地方',0,0,'2020-02-10 21:57:04'),
(21,1,'菜鸟教程','https://www.runoob.com/','学的不仅是技术，更是梦想',0,0,'2020-02-19 18:37:20'),
(22,2,'东南大学','https://www.seu.edu.cn/','东南大学官网',0,0,'2020-02-19 18:38:45'),
(23,0,'人人都是产品经理','http://www.woshipm.com/','产品经理的一切这里都有',0,0,'2020-02-19 18:50:15');

/*Table structure for table `tb_test` */

DROP TABLE IF EXISTS `tb_test`;

CREATE TABLE `tb_test` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `test_info` varchar(50) NOT NULL COMMENT '测试内容',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `tb_test` */

insert  into `tb_test`(`id`,`test_info`) values 
(1,'SpringBoot-MyBatis测试');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
